---
title: CLR 线程的开销
date: 2019-08-11 13:46:56
category: [Backend]
tags: [.NET Standard, CLR]
description: 
---





##### 概述

线程很强大，因为它们使用Windows即使在执行长时间运行的任务时也能随时响应。另外，线程允许用户使用一个应用程序(比如“任务管理器”)强制终止似乎已经冻结的应用程序(它们也有可能正在执行一个长时间运行的任务)。但和一切虚拟化机制一样，线程有空间(内存耗用)和时间(运行时的执行性能)上的开销。

下面我们来更详细的探讨这种开销。每个线程都有以下要素：



##### ① 线程内核对象（thread kernel object）

OS为系统中创建的每个线程都分配并初始化这种数据结构之一。在该数据结构中，包含一组对线程进行描述的属性。数据结构中还包含所谓的线程上下文（thread context）。上下文是一个内存块，其中包含了CPU的寄存器集合。Windows在一台使用X86 CP的计算机上运行时，线程上下文使用约700字节的内存。对于X64和IA64 CPU，上下文分别使用约1240字节和2500字节额内存。



##### ② 线程环境块（thread environment block，TEB）

TEB是在用户模式（应用程序代码能快速访问的地址空间）中分配和初始化的一个内存块。TEB耗用1个内存页

（X86和X64 CPU中是4KB，IA64 CPU中是8KB）。TEB包含线程的异常处理链首（head）。线程进入的每个try块都在链首插入一个节点。线程退出try块时，会从链中删除该节点。除此之外，TEB还包含线程的“线程本地存储”数据，以及有GDI(Graphics Device Interface，图形设备接口)和OpenGL图形使用的一些数据结构。



##### ③ 用户模式栈（user-mode stack）

用户模式栈用于存储传给方法的局部变量和实参。它还包含一个地址；指出当前方法返回时，线程接着应该从什么地方开始执行。默认情况下，Windows为每个新城的用户模式栈分配1MB内存。更具体的说，Windows只是保留1MB地址空间，在线程实际需要时才会提交(调拨)物理内存。



##### ④ 内核模式栈（kernel-mode stack）

应用程序代码向操作系统的一个内核模式的函数传递实参时，还会使用内核模式栈。出于安全方面的原因，针对从用户模式的代码传给内核的任何实参，Windows都会把他们从线程的用户模式栈复制到线程的内核模式栈。一经复制，内核就可验证实参的值。由于应用程序代码不能访问内核模式栈，所以应用程序无法修改验证之后的实参值。OS内核代码将开始对复制的值进行处理。除此之外，内核会调用它自己内部的方法，并利用内核模式栈传递它自己的实参、存储函数的局部变量以及存储返回地址。在32位Windows上运行时，内核模式栈大小为12KB，在64位Windows上运行时，大小则为24KB。



##### ⑤ DLL线程连接（attach）和线程分离（detach）通知

Windows的一个策略是，任何时候在进程中创建一个线程，都会调用哪个进行中加载的所有DLL的DllMain方法，并向该方法传递一个DLL_THREAD_ATTACH标志。类似的，热河时候一个线程终止，都会调用进行中的所有DLL的DllMain方法，并向该方法传递一个DLL_THREAD_DETACH标志。有点DLL需要领用这些通知，为进程中创建、销毁的每个线程执行一些特殊的初始化或（资源）清理操作。例如，C-Runtime库DLL会分配一些线程本地存储状态。线程使用C-Runtime库中包含的函数时，需要用到这些状态。

 





